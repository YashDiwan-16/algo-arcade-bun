#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 2
    bytecblock "totalPool" "totalClaimed" 0x151f7c75 "initialized" "owner" "admin"
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txn NumAppArgs
    bz main_after_if_else@16
    pushbytess 0x70efd7db 0xf6221642 0xf6b7eec8 0x93f7b33c 0x38365145 0xee40f71c 0x74fe2b72 0x2cc22719 0x82ab1ec4 0x6dbede3b // method "init(account,account)void", method "fundPool(uint64)void", method "claimReward(account,byte[],uint64)void", method "isClaimed(account,byte[])bool", method "getClaimedAmount(account,byte[])uint64", method "getTotalPool()uint64", method "getTotalClaimed()uint64", method "getAvailableBalance()uint64", method "updateAdmin(account)void", method "emergencyWithdraw(uint64)void"
    txna ApplicationArgs 0
    match main_init_route@3 main_fundPool_route@4 main_claimReward_route@5 main_isClaimed_route@6 main_getClaimedAmount_route@7 main_getTotalPool_route@8 main_getTotalClaimed_route@9 main_getAvailableBalance_route@10 main_updateAdmin_route@11 main_emergencyWithdraw_route@12

main_after_if_else@16:
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    intc_0 // 0
    return

main_emergencyWithdraw_route@12:
    // smart_contracts/rewards/contract.algo.ts:169
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/rewards/contract.algo.ts:169
    // @arc4.abimethod()
    callsub emergencyWithdraw
    intc_1 // 1
    return

main_updateAdmin_route@11:
    // smart_contracts/rewards/contract.algo.ts:158
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    // smart_contracts/rewards/contract.algo.ts:158
    // @arc4.abimethod()
    callsub updateAdmin
    intc_1 // 1
    return

main_getAvailableBalance_route@10:
    // smart_contracts/rewards/contract.algo.ts:150
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getAvailableBalance
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTotalClaimed_route@9:
    // smart_contracts/rewards/contract.algo.ts:142
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalClaimed
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getTotalPool_route@8:
    // smart_contracts/rewards/contract.algo.ts:134
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalPool
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getClaimedAmount_route@7:
    // smart_contracts/rewards/contract.algo.ts:124
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/rewards/contract.algo.ts:124
    // @arc4.abimethod({ readonly: true })
    callsub getClaimedAmount
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isClaimed_route@6:
    // smart_contracts/rewards/contract.algo.ts:114
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/rewards/contract.algo.ts:114
    // @arc4.abimethod({ readonly: true })
    callsub isClaimed
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claimReward_route@5:
    // smart_contracts/rewards/contract.algo.ts:74
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/rewards/contract.algo.ts:74
    // @arc4.abimethod()
    callsub claimReward
    intc_1 // 1
    return

main_fundPool_route@4:
    // smart_contracts/rewards/contract.algo.ts:60
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/rewards/contract.algo.ts:60
    // @arc4.abimethod()
    callsub fundPool
    intc_1 // 1
    return

main_init_route@3:
    // smart_contracts/rewards/contract.algo.ts:47
    // @arc4.abimethod({ allowActions: ["NoOp"], onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/rewards/contract.algo.ts:24
    // export class GameRewards extends Contract {
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    // smart_contracts/rewards/contract.algo.ts:47
    // @arc4.abimethod({ allowActions: ["NoOp"], onCreate: "require" })
    callsub init
    intc_1 // 1
    return


// smart_contracts/rewards/contract.algo.ts::GameRewards.init(owner: bytes, admin: bytes) -> void:
init:
    // smart_contracts/rewards/contract.algo.ts:47-48
    // @arc4.abimethod({ allowActions: ["NoOp"], onCreate: "require" })
    // init(owner: Account, admin: Account): void {
    proto 2 0
    // smart_contracts/rewards/contract.algo.ts:26
    // owner = GlobalState<Account>();
    bytec 4 // "owner"
    // smart_contracts/rewards/contract.algo.ts:49
    // this.owner.value = owner;
    frame_dig -2
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:29
    // admin = GlobalState<Account>();
    bytec 5 // "admin"
    // smart_contracts/rewards/contract.algo.ts:50
    // this.admin.value = admin;
    frame_dig -1
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    bytec_0 // "totalPool"
    // smart_contracts/rewards/contract.algo.ts:51
    // this.totalPool.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    bytec_1 // "totalClaimed"
    // smart_contracts/rewards/contract.algo.ts:52
    // this.totalClaimed.value = Uint64(0);
    intc_0 // 0
    app_global_put
    // smart_contracts/rewards/contract.algo.ts:38
    // initialized = GlobalState<boolean>();
    bytec_3 // "initialized"
    // smart_contracts/rewards/contract.algo.ts:53
    // this.initialized.value = true;
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.fundPool(paymentAmount: uint64) -> void:
fundPool:
    // smart_contracts/rewards/contract.algo.ts:60-61
    // @arc4.abimethod()
    // fundPool(paymentAmount: uint64): void {
    proto 1 0
    // smart_contracts/rewards/contract.algo.ts:38
    // initialized = GlobalState<boolean>();
    intc_0 // 0
    bytec_3 // "initialized"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:62
    // assert(this.initialized.value, "Not initialized");
    assert // Not initialized
    // smart_contracts/rewards/contract.algo.ts:65
    // const payTxn = gtxn.PaymentTxn(Uint64(0));
    intc_0 // 0
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    intc_0 // 0
    // smart_contracts/rewards/contract.algo.ts:66
    // assert(payTxn.amount === paymentAmount, "Payment amount mismatch");
    gtxns Amount
    frame_dig -1
    ==
    assert // Payment amount mismatch
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "totalPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:68
    // this.totalPool.value += paymentAmount;
    frame_dig -1
    +
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    bytec_0 // "totalPool"
    // smart_contracts/rewards/contract.algo.ts:68
    // this.totalPool.value += paymentAmount;
    swap
    app_global_put
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.claimReward(recipient: bytes, milestoneId: bytes, rewardAmount: uint64) -> void:
claimReward:
    // smart_contracts/rewards/contract.algo.ts:74-79
    // @arc4.abimethod()
    // claimReward(
    //   recipient: Account,
    //   milestoneId: bytes,
    //   rewardAmount: uint64
    // ): void {
    proto 3 0
    // smart_contracts/rewards/contract.algo.ts:38
    // initialized = GlobalState<boolean>();
    intc_0 // 0
    bytec_3 // "initialized"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:80
    // assert(this.initialized.value, "Not initialized");
    assert // Not initialized
    // smart_contracts/rewards/contract.algo.ts:81
    // assert(Txn.sender === this.admin.value, "Only admin can approve claims");
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:29
    // admin = GlobalState<Account>();
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:81
    // assert(Txn.sender === this.admin.value, "Only admin can approve claims");
    ==
    assert // Only admin can approve claims
    // smart_contracts/rewards/contract.algo.ts:82
    // assert(rewardAmount > Uint64(0), "Invalid reward amount");
    frame_dig -1
    assert // Invalid reward amount
    // smart_contracts/rewards/contract.algo.ts:194
    // return user.bytes.concat(milestoneId);
    frame_dig -3
    frame_dig -2
    concat
    // smart_contracts/rewards/contract.algo.ts:89
    // assert(!claimBox.exists, "Reward already claimed");
    dup
    box_len
    bury 1
    !
    assert // Reward already claimed
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "totalPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    intc_0 // 0
    bytec_1 // "totalClaimed"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:93
    // this.totalPool.value >= this.totalClaimed.value + rewardAmount,
    frame_dig -1
    +
    swap
    dig 1
    >=
    // smart_contracts/rewards/contract.algo.ts:92-95
    // assert(
    //   this.totalPool.value >= this.totalClaimed.value + rewardAmount,
    //   "Insufficient pool balance"
    // );
    assert // Insufficient pool balance
    // smart_contracts/rewards/contract.algo.ts:98-104
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: rewardAmount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -3
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:98-103
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: rewardAmount,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/rewards/contract.algo.ts:102
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:98-104
    // itxn
    //   .payment({
    //     receiver: recipient,
    //     amount: rewardAmount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/rewards/contract.algo.ts:107
    // claimBox.value = rewardAmount;
    frame_dig -1
    itob
    uncover 2
    swap
    box_put
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    bytec_1 // "totalClaimed"
    // smart_contracts/rewards/contract.algo.ts:108
    // this.totalClaimed.value += rewardAmount;
    swap
    app_global_put
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.isClaimed(user: bytes, milestoneId: bytes) -> uint64:
isClaimed:
    // smart_contracts/rewards/contract.algo.ts:114-115
    // @arc4.abimethod({ readonly: true })
    // isClaimed(user: Account, milestoneId: bytes): boolean {
    proto 2 1
    // smart_contracts/rewards/contract.algo.ts:194
    // return user.bytes.concat(milestoneId);
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/rewards/contract.algo.ts:118
    // return claimBox.exists;
    box_len
    bury 1
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.getClaimedAmount(user: bytes, milestoneId: bytes) -> uint64:
getClaimedAmount:
    // smart_contracts/rewards/contract.algo.ts:124-125
    // @arc4.abimethod({ readonly: true })
    // getClaimedAmount(user: Account, milestoneId: bytes): uint64 {
    proto 2 1
    // smart_contracts/rewards/contract.algo.ts:194
    // return user.bytes.concat(milestoneId);
    frame_dig -2
    frame_dig -1
    concat
    dup
    // smart_contracts/rewards/contract.algo.ts:128
    // return claimBox.exists ? claimBox.value : Uint64(0);
    box_len
    bury 1
    bz getClaimedAmount_ternary_false@2
    frame_dig 0
    box_get
    assert // Box must have value
    btoi

getClaimedAmount_ternary_merge@3:
    // smart_contracts/rewards/contract.algo.ts:128
    // return claimBox.exists ? claimBox.value : Uint64(0);
    swap
    retsub

getClaimedAmount_ternary_false@2:
    // smart_contracts/rewards/contract.algo.ts:128
    // return claimBox.exists ? claimBox.value : Uint64(0);
    intc_0 // 0
    b getClaimedAmount_ternary_merge@3


// smart_contracts/rewards/contract.algo.ts::GameRewards.getTotalPool() -> uint64:
getTotalPool:
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "totalPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:136
    // return this.totalPool.value;
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.getTotalClaimed() -> uint64:
getTotalClaimed:
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    intc_0 // 0
    bytec_1 // "totalClaimed"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:144
    // return this.totalClaimed.value;
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.getAvailableBalance() -> uint64:
getAvailableBalance:
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "totalPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    intc_0 // 0
    bytec_1 // "totalClaimed"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:152
    // return this.totalPool.value - this.totalClaimed.value;
    -
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.updateAdmin(newAdmin: bytes) -> void:
updateAdmin:
    // smart_contracts/rewards/contract.algo.ts:158-159
    // @arc4.abimethod()
    // updateAdmin(newAdmin: Account): void {
    proto 1 0
    // smart_contracts/rewards/contract.algo.ts:38
    // initialized = GlobalState<boolean>();
    intc_0 // 0
    bytec_3 // "initialized"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:160
    // assert(this.initialized.value, "Not initialized");
    assert // Not initialized
    // smart_contracts/rewards/contract.algo.ts:161
    // assert(Txn.sender === this.owner.value, "Only owner can update admin");
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:26
    // owner = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "owner"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:161
    // assert(Txn.sender === this.owner.value, "Only owner can update admin");
    ==
    assert // Only owner can update admin
    // smart_contracts/rewards/contract.algo.ts:29
    // admin = GlobalState<Account>();
    bytec 5 // "admin"
    // smart_contracts/rewards/contract.algo.ts:162
    // this.admin.value = newAdmin;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/rewards/contract.algo.ts::GameRewards.emergencyWithdraw(amount: uint64) -> void:
emergencyWithdraw:
    // smart_contracts/rewards/contract.algo.ts:169-170
    // @arc4.abimethod()
    // emergencyWithdraw(amount: uint64): void {
    proto 1 0
    // smart_contracts/rewards/contract.algo.ts:38
    // initialized = GlobalState<boolean>();
    intc_0 // 0
    bytec_3 // "initialized"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:171
    // assert(this.initialized.value, "Not initialized");
    assert // Not initialized
    // smart_contracts/rewards/contract.algo.ts:172
    // assert(Txn.sender === this.owner.value, "Only owner can withdraw");
    txn Sender
    // smart_contracts/rewards/contract.algo.ts:26
    // owner = GlobalState<Account>();
    intc_0 // 0
    bytec 4 // "owner"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:172
    // assert(Txn.sender === this.owner.value, "Only owner can withdraw");
    swap
    dig 1
    ==
    assert // Only owner can withdraw
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "totalPool"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:35
    // totalClaimed = GlobalState<uint64>();
    intc_0 // 0
    bytec_1 // "totalClaimed"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/rewards/contract.algo.ts:174
    // this.totalPool.value >= this.totalClaimed.value + amount,
    frame_dig -1
    +
    dig 1
    <=
    // smart_contracts/rewards/contract.algo.ts:173-176
    // assert(
    //   this.totalPool.value >= this.totalClaimed.value + amount,
    //   "Insufficient available balance"
    // );
    assert // Insufficient available balance
    // smart_contracts/rewards/contract.algo.ts:178-184
    // itxn
    //   .payment({
    //     receiver: this.owner.value,
    //     amount: amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    frame_dig -1
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/rewards/contract.algo.ts:178-183
    // itxn
    //   .payment({
    //     receiver: this.owner.value,
    //     amount: amount,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/rewards/contract.algo.ts:182
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/rewards/contract.algo.ts:178-184
    // itxn
    //   .payment({
    //     receiver: this.owner.value,
    //     amount: amount,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/rewards/contract.algo.ts:186
    // this.totalPool.value -= amount;
    frame_dig -1
    -
    // smart_contracts/rewards/contract.algo.ts:32
    // totalPool = GlobalState<uint64>();
    bytec_0 // "totalPool"
    // smart_contracts/rewards/contract.algo.ts:186
    // this.totalPool.value -= amount;
    swap
    app_global_put
    retsub
